# 전역 상태 관리 라이브러리

## 전역 상태 관리 문제 해결하기

- 리액트는 컴포넌트라는 개념을 중심으로 설계됨. 컴포넌트 모델에서 모든 것이 재사용 가능함

### 전역 상태를 설계할 때 문제점

- 전역상태를 읽는 방법
  - 전역 상태는 여러 값을 가질 수 있고, 전역 상태를 사용하는 컴포넌트는 전역 상태의 모든 값이 필요하지 않은 경우가 있음
  - 전역 상태가 바뀌면 리렌더링이 발생하는데, 변경된 값이 컴포넌트와 관련 없는 경우에도 리렌더링이 발생함
- 전역 상태에 값을 넣거나 갱신하는 방법
  - 전역 상태는 여러 값을 가질 수 있으며, 그중 일부는 중첩된 객체일 수 있음
  - 이 때 하나의 전역 변수를 가지고 개발자가 직접 값을 변경하는 것은 좋은 방법이 아닐 수 있음
- 전역 상태 변경을 감지하기 위해서는 전역 상태를 변경하는 함수를 제공해야 함

```tsx
// 클로저에서 변수를 숨겨 직접 변수를 변경할 수 없도록 하는 방법
const createContainer = () => {
  let state = { a: 1, b: 2 }
  const getState = () => state;
  const setState = (...) => { ... };
  return { getState, setState }
}

const globalContainer = createContainer();
globalContainer.setState(...);
```

## 데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 사용

### 데이터 중심 접근 방식

- 모듈 상태가 리액트 외부의 자바스크립트 메모리에 있기 때문에 모듈 상태를 사용하는 편이 적합
- 모듈 상태는 리액트가 렌더링을 시작하기 전이나 모든 리액트 컴포넌트가 마운트 해제된 후에도 존재할 수 있음
- 데이터 중심 접근 방식을 사용하는 전역 상태 라이브러리는 모듈 상태를 생성하고 모듈 상태를 리액트 컴포넌트에 연결하는 API를 제공
- 모듈 상태는 보통 상태 변수에 접근하고 갱신하는 메서드를 가진 store 객체로 감싸는 방식
- 팩토리 함수를 제공하며, 이러한 팩토리 함수에서는 리액트 컴포넌트에서 사용할 전역 상태를 초기화하는 함수를 생성

### 컴포넌트 중심 접근 방식

- 컴포넌트 중심 접근 방식을 사용하면 컴포넌트를 먼저 설계할 수 있음. 또한 데이터 모델이 컴포넌트에 강한 의존성을 가지고 있음
- 컴포넌트 생명 주기 내에서 전역 상태를 유지하는 것이 더 적합. why? 의존하는 컴포넌트가 모두 마운트 해제되면 전역 상태도 함께 사라지기 때문

### 예외

- 무조건 하나만 사용하는 것이 아니라 상황에 맞춰서 두 가지 접근 방식을 함께 사용할 수 있음
- 모듈 상태는 대체로 싱글턴 패턴으로 구현되지만 하위 트리에 대해 여러 모듈 상태를 만들 수 있으며, 생명 주기를 제어할 수 있음

## 리렌더링 최적화

- 일반적으로 전역 상태는 여러 속성이 있으며, 중첩된 객체일 수 있음

```tsx
let state = {
  a: 1,
  b: { c: 2, d: 3 },
  e: { f: 4, g: 5 },
};
```

### 선택자 함수 사용

- 선택자 함수는 상태를 받아 상태의 일부를 반환

```tsx
const Component = () => {
  const value = useSelector((state) => state.b.c);
  return <>{value}</>;
};
```

- useSelector는 상태가 변경될 때마다 선택자 함수의 결과를 비교하는 데 사용됨
- 따라서 선택자 함수는 동일한 입력이 주어졌을 때 state를 참조해서 동일한 결과를 반환하는 것이 중요함
- 매우 유연하여 상태의 일부뿐만 아니라 파생된 값도 반환할 수 있음
- 컴포넌트의 어느 부분을 사용할 지 명시적으로 지정하는 방법이므로 이를 수동 최적화라고 함

```tsx
const Component = () => {
  const value = useSelector((state) => state.b.c * 2);
  return <>{value}</>;
};
```

\*\* 선택자 함수가 반환하는 값이 숫자와 같은 원시 값이면 문제가 없음. 하지만 선택자 함수가 파생된 객체 값을 반환하는 경우에는 메모이제이션을 사용해 동일한 객체를 반환하도록 해야함

### 속성 접근 방지

- 속성 접근을 감지하고 감지한 정보를 렌더링 최적화에 사용할 수 있는 상태 사용 추적(state usage tracking)이 있음

```tsx
const Component = () => {
  const trackedState = useTrackedState();
  return <p>{trackedState.b.c}</p>;
};
```

- 이 훅(임의의 훅)을 통해 trackedState가 .b.c 속성에 접근했을음 감지할 수 있고, .b.c 속성 값이 변경될 때만 useTrackedState가 리렌더링을 발생시킴
- useTrackedState를 구현하려면 상태 객체에 대한 속성 접근을 확인하기 위한 프락시(proxy)가 필요함
- 경우에 따라 useTrackedState보다 useSelector가 더 적합한 사례가 있음. useSelector는 파생 값을 만들 수 있기에 상태를 더 간단한 값으로 만들 수 있ㅇ므

```tsx
const Component = () => {
  const isSmall = useSelector((state) => state.a < 10);
  return <p>{isSmall ? 'small' : 'big'}</p>;
};

const Component2 = () => {
  const isSmall = useTrackedState().a < 10;
  return <p>{isSmall ? 'small' : 'big'}</p>;
};
```

- 기능 면에서 useTrackedState를 사용한 컴포넌트는 잘 작동하지만 state.a가 변경될 때마다 리렌더링 됨. 하지만 useSelector를 사용하면 isSmall이 변경될 때만 리렌더링 됨

### 아톰 사용

- 아톰은 리렌더링을 발생시키는데 사용되는 최소 상태 단위임
- 전체 전역 상태를 구독해서 리렌더링을 피하는 대신 아톰을 사용하면 좀 더 세분화해서 구독하는 것이 가능함

```tsx
const globalState = {
  a: atom(1),
  b: atom(2),
  e: atom(3),
};

const Component = () => {
  const value = useAtom(globalState.a);
  return <>{value}</>;
};
```

- 아톰을 사용하는 접근 방식은 수동 최적화와 자동 최적화의 중간 정도임. 아톰과 파생 값의 정의는 명시적이지만 의존성 추적은 자동으로 됨
